**MVCC（Multi-Version Concurrency Control，多版本并发控制）** 是数据库管理系统中用来实现高并发访问的一种核心技术。

它的核心思想是：**“读不加锁，读写不冲突”**。通过保存数据的历史版本，使得读操作和写操作可以并发执行，极大地提升了数据库的并发性能。

## MySQL 实现 MVCC 机制原理

### 核心机制原理

InnoDB 实现 MVCC 主要依赖于三个核心机制：**隐藏字段（隐式列）**、**Undo Log（回滚日志）** 和 **Read View（读视图）**。

#### 1. 隐藏字段
在 InnoDB 的数据表中，除了我们自己定义的列之外，每行记录实际上都包含几个对用户不可见的隐藏列：
*   **`DB_TRX_ID` (6字节)**：事务ID。记录**最后一次**插入或更新该行的事务的 ID。
*   **`DB_ROLL_PTR` (7字节)**：回滚指针。指向该行记录的上一个版本（存储在 Undo Log 中）。

#### 2. Undo Log（回滚日志）与版本链
Undo Log 主要用于事务的回滚和 MVCC。
当一个事务修改（UPDATE/DELETE）某行记录时，InnoDB 不会直接覆盖原来的数据，而是会将旧版本的数据写入 Undo Log 中。
*   **版本链**：当前数据表中的最新记录，通过其隐藏的 `DB_ROLL_PTR` 指针，指向 Undo Log 中的上一个版本；上一个版本又指向更早的版本。这样就把同一行数据的多个历史版本串联成了一条**版本链**。

#### 3. Read View（读视图）
**Read View 是 MVCC 的核心，它是事务在进行“快照读”（普通的 SELECT）时生成的一个一致性视图。** 它的作用是用来判断版本链中的哪个版本对当前事务是可见的。

Read View 包含四个核心属性：
1.  **`creator_trx_id`**：创建当前 Read View 的事务 ID。
2.  **`m_ids`**：在生成 Read View 的时刻，系统中**活跃且未提交**的事务 ID 列表。
3.  **`min_trx_id`**：`m_ids` 中的最小值。
4.  **`max_trx_id`**：生成 Read View 时系统应该分配给下一个事务的 ID（也就是当前系统最大事务 ID + 1）。


### MVCC 的可见性判断算法

当事务读取一条记录时，会沿着这条记录的 **版本链** 从新到旧依次寻找，针对每个版本的 `DB_TRX_ID`（记为 `trx_id`），根据 Read View 进行如下判断：

1.  **`trx_id == creator_trx_id`**：
    当前版本就是当前事务自己修改的。**（可见）**
2.  **`trx_id < min_trx_id`**：
    修改该版本的事务，在生成 Read View 之前就已经提交了。**（可见）**
3.  **`trx_id >= max_trx_id`**：
    修改该版本的事务，是在生成 Read View 之后才开启的。**（不可见）**
4.  **`min_trx_id <= trx_id < max_trx_id`**：
    这种情况下，需要判断 `trx_id` 是否在 `m_ids`（活跃事务列表）中：
    *   **在 `m_ids` 中**：说明生成 Read View 时，修改该版本的事务还没提交。**（不可见）**
    *   **不在 `m_ids` 中**：说明生成 Read View 时，修改该版本的事务已经提交了。**（可见）**

**如果当前最新版本不可见，就顺着 `DB_ROLL_PTR` 找到 Undo Log 中的上一个版本，重新执行上述判断，直到找到第一个对当前事务可见的版本为止。**

备注：为什么需要判断4？
因为，事务的执行顺序并不是强先后的，现分配到事务的sql语句，并不一定先执行完，可能导致事务id后的已经执行完，而该事务id没执行完，所以需要判断4

### MVCC 如何解决事务并发问题？

事务并发常见的问题有：**脏读、不可重复读、幻读**。

MVCC 在 **RC（读已提交）** 和 **RR（可重复读）** 两种隔离级别下发挥作用，但生成 Read View 的时机不同，从而解决了不同的并发问题。

#### 1. 解决“脏读”（Dirty Read）
*   **问题**：事务 A 读取到了事务 B 未提交的数据。
*   **MVCC 解决机制**：在 RC 和 RR 级别下，事务 A 读取数据时会生成 Read View。因为事务 B 还没有提交，所以 B 的事务 ID 一定包含在事务 A 的 `m_ids`（活跃事务列表）中。根据可见性算法，未提交的 B 所做的修改对 A 是**不可见**的。A 会顺着版本链找到 B 修改前的旧版本。这就**彻底杜绝了脏读**。

#### 2. 解决“不可重复读”（Non-Repeatable Read）
*   **问题**：事务 A 在两次读取同一条数据之间，事务 B 修改了该数据并提交，导致 A 两次读到的数据不一样。
*   **RC 级别下的现象**：在 RC（读已提交）级别下，**每一次 SELECT 都会生成一个新的 Read View**。这意味着如果 B 提交了，A 第二次 SELECT 生成的新 Read View 中，B 就不在 `m_ids` 里了，A 就能看到 B 的修改，导致不可重复读。
*   **RR 级别下的 MVCC 解决机制**：在 RR（可重复读）级别下，**Read View 只在事务的第一次 SELECT 时生成一次，之后整个事务期间复用这个 Read View**。
    因此，就算事务 B 在 A 的两次 SELECT 之间提交了修改，由于 A 的 Read View 并没有更新，B 的事务 ID 仍然在 A 眼中属于“未来事务”或“活跃事务”，根据规则依然**不可见**。A 只能读到它第一次 SELECT 时那个时间点的一致性快照，从而**完美解决了不可重复读**。

#### 3. 解决“幻读”（Phantom Read）
*   **问题**：事务 A 按某种条件范围查询，事务 B 在该范围内插入了新数据并提交。事务 A 再次查询该范围，发现多出了“幻影”记录。
*   **MVCC 对快照读的解决**：对于普通的 SELECT（快照读），RR 级别下因为全程复用同一个 Read View，即使 B 插入了新数据，新数据的 `trx_id` 对 A 来说大于 `max_trx_id`，属于不可见的“未来数据”。因此，**MVCC 解决了快照读下的幻读问题**。

## PG 实现 MVCC 的核心原理

PostgreSQL（简称 PG）的 MVCC 实现机制与 MySQL (InnoDB) **有着本质的区别**。

如果说 MySQL 的 MVCC 是一招“移花接木”（把旧数据移到 Undo Log 里），那么 PG 的 MVCC 就是一招**“添砖加瓦”（Append-Only，旧数据和新数据都直接存在数据表里）**。

下面我们对比着 MySQL，为你详细拆解 PG 是如何实现 MVCC 的。

### 核心机制原理

#### 1. 隐藏字段（Tuple 头部信息）
在 PG 中，表里的一行数据被称为一个 **Tuple（元组）**。与 MySQL 类似，PG 的每个 Tuple 也有隐藏字段，最核心的是这三个：
*   **`xmin`**：**创建**（Insert / Update）这个元组的事务 ID。
*   **`xmax`**：**删除**（Delete / Update）这个元组的事务 ID。如果这个元组还没被删除或修改，`xmax` 就是 0。
*   **`ctid`**：类似于 MySQL 的回滚指针，但它指向的是**同一个数据块中该记录的下一个最新版本**的物理位置。

> **注意 PG 的 Update 逻辑**：在 PG 中，**没有真正意义上的原地修改（Update）**。
> 当你 Update 一行数据时，PG 实际上做了两件事：
> 1. 把旧元组的 `xmax` 填上当前事务 ID（相当于标记**删除**旧数据）。
> 2. 插入一个全新的元组，`xmin` 为当前事务 ID，`xmax` 为 0（相当于**新增**新数据）。
> 3. 把旧元组的 `ctid` 指向新元组，形成版本链。

#### 2. CLOG（Commit Log，事务提交日志）
在 MySQL 中，判断一个事务是否提交，通常需要结合 Undo Log 和活跃事务列表。
但在 PG 中，所有的新旧元组都在同一张表里，怎么知道某个 `xmin` 或 `xmax` 对应的事务到底有没有提交呢？

PG 专门维护了一个极小的文件叫 **`pg_xact`（老版本叫 CLOG）**。它其实是一个**位图（Bitmap）**，记录了系统中每一个事务的状态：
*   00：IN_PROGRESS（进行中）
*   01：COMMITTED（已提交）
*   10：ABORTED（已回滚/中止）

#### 3. Snapshot（快照，等价于 MySQL 的 Read View）
当 PG 的事务执行查询时，也会生成一个快照（Snapshot）。它里面的结构和 MySQL 的 Read View 几乎一模一样（只是叫法变了）：
*   **`xmin`**：当前系统中活跃的最老事务 ID。（相当于 MySQL 的 `min_trx_id`）
*   **`xmax`**：下一个将被分配的事务 ID。（相当于 MySQL 的 `max_trx_id`）
*   **`xip` (Active XIDs)**：生成快照时，系统中所有活跃事务 ID 的列表。（相当于 MySQL 的 `m_ids`）

> *特别提示：请不要把 Snapshot 里的 `xmin`/`xmax` 和 Tuple 隐藏字段的 `xmin`/`xmax` 搞混了，它们同名但意义不同。*

---

### 二、 PG 的可见性判断逻辑

当一个事务拿到 Snapshot 后，去表里扫数据，对于看到的每一个元组，判断能不能“看到”它，需要经过两步：

#### 第一步：判断它是不是“已经生出来了”？（查元组的 `xmin`）
PG 会拿元组身上的 `xmin`（创建它的事务ID），去套用我们刚才学的“区间判断”法则：
1. `xmin < 快照的 xmin`：老早就提交了，**生出来了**。
2. `xmin >= 快照的 xmax`：未来的事务创建的，**没生出来**（不可见）。
3. 在中间区间：查快照的 `xip` 活跃列表。在列表里，说明**没生出来**；不在列表里，说明**生出来了**。

*(如果此时查 CLOG 发现这个 `xmin` 对应的事务是 ABORTED（回滚了），那就当它是一次失败的流产，直接不可见。)*

#### 第二步：判断它是不是“已经死掉了”？（查元组的 `xmax`）
如果第一步判断它“生出来了”，还要看它现在的状态：
*   **如果 `xmax` = 0**：还没人动它，它活得好好的，**对当前事务绝对可见**。
*   **如果 `xmax` != 0**：说明有事务删除了它（或更新了它）。
    拿这个 `xmax` 再去套用一遍上述的规则，判断这个“删除动作”对当前事务是否生效：
    *   如果删除动作对你可见：说明它真死了，**当前元组不可见**。你会顺着 `ctid` 去找下一个新版本。
    *   如果删除动作对你不可见（比如删除它的事务还没提交，或者在你的快照生成之后才开始的）：说明在你的时间线里它还没死，**当前元组对你依然可见**。

### 三、 PG 与 MySQL MVCC 的优劣势对比

由于底层设计的巨大差异（PG 是 Append-Only，MySQL 是 Undo Log），带来了截然不同的特性：

#### 1. 事务回滚（Rollback）的代价
*   **MySQL**：回滚很痛苦。要把 Undo Log 里的旧数据反向操作一遍恢复到表里。大事务回滚极慢。
*   **PG**：回滚**瞬间完成**！因为新旧数据都在表里，PG 只需要去 CLOG 里把这个事务的状态从 IN_PROGRESS 改成 ABORTED（只要改 2 个 bit 位）。其他事务读取时，查 CLOG 发现是 ABORTED，直接忽略这些数据即可。

#### 2. 表膨胀（Table Bloat）与垃圾回收
*   **MySQL**：旧版本数据放在 Undo Log 表空间，主表永远只存最新数据，主表不会因为频繁更新而极度膨胀。Undo Log 也会自动按页清理。
*   **PG 的痛点**：因为旧数据和新数据全挤在主表里，如果频繁 Update / Delete，表的文件体积会迅速膨胀，里面塞满了无用的“死元组”（Dead Tuples）。
*   **PG 的解决办法 —— VACUUM（真空清理）**：PG 必须运行一个后台进程叫做 `AutoVacuum`。它会定期扫表，找到那些“对所有活跃快照都已经不可见”的死元组，把它们占用的物理空间标记为可用，供新数据覆盖。如果长时间不 Vacuum，性能会断崖式下跌。

#### 3. 索引的维护（HOT 机制）
*   **MySQL**：只改了非索引列，二级索引是不需要动的，因为二级索引存的是主键，主键没变。
*   **PG 的痛点**：PG 的二级索引叶子节点存的是数据的物理位置（`ctid`）。因为 Update 会产生新元组（物理位置变了），这就导致**哪怕只更新了一个完全不相关的字段，所有的二级索引都要跟着增加一条指向新元组的记录**（索引膨胀）。
*   **PG 的解决办法 —— HOT（Heap-Only Tuples）**：为了解决这个问题，PG 引入了 HOT 优化。如果更新的字段没有被索引，且同一个数据页里还有剩余空间，PG 就只在数据页里插入新元组，利用页内的指针重定向，而不需要去更新索引树，大大缓解了索引膨胀。


## 总结

*   **MySQL 核心**：原位更新 + Undo Log 版本链 + Read View。主表干净，回滚慢。
*   **PG 核心**：追加插入（Append-Only） + 同表版本链（ctid）+ CLOG + Snapshot。回滚极快，但容易产生表膨胀，严重依赖 VACUUM 机制来清理垃圾。

PG 的这种设计在应对读多写少、或者追求极致的回滚速度时表现极其优雅，但在面临极高频的 Update 场景时，对 DBA 的调优（尤其是对 AutoVacuum 的调优）提出了很高的要求。

