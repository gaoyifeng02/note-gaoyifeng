总结：
- 使用： explain (选项1, ... ) SQL ，选项可以控制SQL是否真实执行，具体展示多少信息以及格式化输出。

`EXPLAIN` 有很多强大的选项。掌握它们能让你应对更多复杂的场景（比如分析写操作、对比环境差异、或者使用可视化工具）。

这些选项分为三类：**执行控制类**、**信息细节类**、**格式输出类**。

基本语法是：
```sql
EXPLAIN (选项1, 选项2, ...) SQL语句;
```

## 使用

### 第一类：执行控制类

#### 1. `ANALYZE
*   **默认**：OFF
*   **作用**：**真的执行** SQL。
*   **注意**：只有开启了它，后面的 `BUFFERS`、`TIMING`、`WAL` 等选项才有效（因为不跑就没有这些数据）。

### 第二类：信息细节类

#### 2. `VERBOSE`（啰嗦模式）
*   **默认**：OFF
*   **作用**：显示更多内部细节，特别是**输出列（Output）**信息。
*   **场景**：
    *   当你发现 SQL 实际上不需要查某些字段，但执行计划里却显示它在搬运这些字段时。
    *   当使用了函数或复杂的表达式，你想知道数据库到底把它们解析成了什么名字。
*   **效果示例**：
    *   普通：`Seq Scan on risk`
    *   Verbose：`Seq Scan on public.risk (Output: id, account_id, time ...)` —— 它会把 schema 和涉及的所有列都列出来。

#### 3. `COSTS`（成本开关）
*   **默认**：**ON**
*   **作用**：显示 `(cost=...)` 那一串数字。
*   **场景**：
    *   通常我们需要看它。
    *   **什么时候关掉？** 当你在做教学演示，或者对比两个 SQL 的结构差异时，长长的数字会干扰视线，关掉它能让你只关注“执行路径”（是走了索引还是扫了全表）。
*   **命令**：`EXPLAIN (COSTS OFF) ...`

#### 4. `TIMING`（计时开关）
*   **默认**：**ON**（只要开启 ANALYZE）
*   **作用**：显示每个节点的 `actual time=...`。
*   **场景**：
    *   **为什么要关掉？** 在某些操作系统上，频繁获取系统时间（gettimeofday）本身开销很大。如果你发现 `EXPLAIN ANALYZE` 让查询变得极慢（比平时跑慢得多），可以尝试 `EXPLAIN (ANALYZE, TIMING OFF)`。这样只统计行数，不统计每一微秒的时间，减少测量误差。

#### 5. `WAL`（预写日志监控） *PG 13+ 版本新增*
*   **默认**：OFF
*   **作用**：显示查询产生的 **WAL（Write-Ahead Log）** 日志量。
*   **场景**：
    *   **写操作优化**：对于 `INSERT/UPDATE/DELETE`，或者带有大量临时文件的排序操作。
    *   它会告诉你：这条 SQL 产生了多少日志记录（Records）、多少字节（Bytes）以及多少全页写入（FPI）。
    *   **例子**：如果一个 `UPDATE` 慢，开启 `WAL` 发现产生了 GB 级别的日志，说明可能是 Full Page Writes 导致的 I/O 瓶颈。

#### 6. `SETTINGS`（环境配置） *PG 12+ 版本新增*
*   **默认**：OFF
*   **作用**：显示**影响了这次执行计划的非默认参数**。
*   **场景**：
    *   **“救命，开发环境快，生产环境慢！”**
    *   加上这个选项，它会直接列出：`work_mem = '64MB', random_page_cost = 1.1`。你一看就知道：“哦！原来是生产环境配了这个参数导致的！”
    *   它只显示那些**被修改过**且**确实影响了计划**的参数，非常实用。

#### 7. `SUMMARY`（总结信息）
*   **默认**：OFF（但如果用了 ANALYZE 会自动变成 ON）
*   **作用**：在最后显示 `Planning Time`（规划耗时）和 `Execution Time`（执行耗时）。
*   **场景**：
    *   有时候 SQL 执行很快（0.1ms），但 `Planning Time` 却要 100ms（比如表分区太多，规划器算不过来了）。如果不看 Summary，你可能会忽略规划器的开销。


### 第三类：格式输出类（决定“给谁看”）

#### 8. `FORMAT`（格式化）
*   **默认**：TEXT（就是我们现在看的样子）
*   **选项**：`TEXT`, `XML`, `JSON`, `YAML`
*   **作用**：改变输出格式。
*   **场景**：
    *   **JSON**：**最有用！** 配合可视化工具（如 [PEV2](https://explain.dalibo.com/) 或 PgAdmin 的图形化解释器）。
    *   你可以把 JSON 复制粘贴到网页工具里，它会画出漂亮的火焰图或树状图，帮你一眼看出哪里最慢，而不用盯着枯燥的文本看。

**命令示例**：
```sql
EXPLAIN (ANALYZE, FORMAT JSON) SELECT * FROM risk;
```


### 总结：一套“组合拳”推荐

根据不同的目的，我推荐几套常用的参数组合：

1.  **日常看病（标准版）** —— **最常用**
    ```sql
    EXPLAIN (ANALYZE, BUFFERS) ...
    ```
    *   *看真实时间、真实行数、内存/磁盘 I/O。*

2.  **疑难杂症（豪华版）**
    ```sql
    EXPLAIN (ANALYZE, BUFFERS, VERBOSE, SETTINGS) ...
    ```
    *   *看 I/O、看每一列细节、看是不是配置参数捣鬼。*

3.  **我要发给别人看/用工具看（JSON 版）**
    ```sql
    EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON) ...
    ```
    *   *生成 JSON，扔进可视化分析工具。*

4.  **只看写操作压力（写优化版）**
    ```sql
    EXPLAIN (ANALYZE, WAL) ...
    ```
    *   *看产生了多少日志垃圾。*



没问题！我们把它当做一门外语来学，我把这句话里的每一个“单词”都拆开，用最通俗的例子给你解释清楚。

我们面对的是这段像天书一样的日志：

codeCode

```
Index Only Scan using ix_risk_account_happen on risk  (cost=0.57..3229783.33 rows=3298697 width=0) (actual time=0.626..73415.866 rows=2480978 loops=1)
Buffers: shared hit=879847 read=622250 dirtied=114 written=12390
Heap Fetches: 2485841
```

为了方便理解，请想象你在**图书馆查书**。

- **数据库表（Heap）** = 图书馆的书架（存放真实的书）。
    
- **索引（Index）** = 图书馆的检索电脑/目录卡片（只存书名和位置，不存书的内容）。
    
- **内存（Buffer）** = 你的书桌（拿得快）。
    
- **磁盘（Disk）** = 地下仓库（拿得慢，要走很远）。
    

## 分析


### 第一部分：他在干什么？（动作篇）

> **Index Only Scan using ix_risk_account_happen on risk**

- **Index Only Scan（仅索引扫描）**：
    
    - **意思**：数据库觉得：“你要查的数据（比如统计数量），光看目录卡片（索引）就够了，不需要去书架上翻书（回表）。”
        
    - **预期**：这通常是最快的方式，因为目录卡片比书轻得多。
        
- **using ix_risk_account_happen**：
    
    - **意思**：它选用了名为 ix_risk_account_happen 的这套目录卡片。
        
- **on risk**：
    
    - **意思**：这是针对 risk 这个图书馆（表）的操作。
        

---

### 第二部分：他原本是怎么想的？（预估篇）

这一部分括号里的内容 (cost=... rows=... width=...) 是数据库在**动手之前**，坐在办公室里掐指算出来的**计划书**。

> **cost=0.57..3229783.33**

- **是什么**：**代价（成本分）**。这是数据库内部的“货币”。它不代表秒，也不代表钱，就是一个用来比较的虚拟分数。
    
- **0.57（启动成本）**：
    
    - **解释**：数据库估算，从开始干活到**找到第 1 条**符合条件的数据，需要花费 0.57 分。
        
    - **意义**：有些查询启动很慢（比如要先排序），有些很快（直接读索引）。这里 0.57 说明启动极快。
        
- **3229783.33（总成本）**：
    
    - **解释**：数据库估算，**找完所有**符合条件的数据，总共要花费 322 万分。
        
    - **意义**：这个数字越大，说明数据库觉得这活儿越累。
        

> **rows=3298697**

- **是什么**：**预估行数**。
    
- **解释**：数据库看了一眼它的“统计小本本”，猜大概有 329 万条记录符合你的条件。
    
- **为什么重要**：如果这里猜是 1 行，实际有 1 亿行，那数据库就会选错工具（比如选了全表扫描），导致灾难。在你这里，预估 329 万 vs 实际 248 万，误差不算大，属于正常范围。
    

> **width=0**

- **是什么**：**行宽度**（字节）。
    
- **解释**：数据库觉得每行结果占 0 个字节。
    
- **为什么是 0？**：因为你执行的是 SELECT count(*)。你只要一个数字（总数），不需要把书的内容拿出来，所以每行返回的数据量几乎为 0。
    

---

### 第三部分：实际发生了什么？（真相篇）

这一部分 (actual time=... rows=... loops=...) 是 ANALYZE 带来的，是**真正跑完**后的实测数据。

> **actual time=0.626..73415.866**

这是最直观的性能指标，单位是**毫秒（ms）**。

- **0.626（第一行时间）**：
    
    - **解释**：数据库**找到第 1 个**符合条件的记录，只用了 0.6 毫秒。
        
    - **感觉**：此时用户还没感觉慢。
        
- **73415.866（结束时间）**：
    
    - **解释**：数据库**找完最后 1 个**记录，总共用了 73415 毫秒（约 **73.4 秒**）。
        
    - **感觉**：用户已经等到崩溃了。这就是你报告里提到的“严重性能延迟”。
        

> **rows=2480978**

- **是什么**：**真实行数**。
    
- **解释**：实际数出来的结果是 248 万行。
    

> **loops=1**

- **是什么**：**循环次数**。
    
- **解释**：这个扫描动作执行了 1 次。
    
- **注意**：如果是复杂的关联查询（Join），某个表可能会被扫描几万次，那时总时间 = actual time × loops。这里是 1，所以时间就是 73 秒。
    

---

### 第四部分：资源到底耗哪儿了？（I/O 篇）

这一部分 Buffers: ... 是 BUFFERS 选项带来的。这是**核心中的核心**。  
PostgreSQL 把所有数据都切成一块一块的，每一块叫一个 **Page（页）**，大小是 **8KB**。

> **shared hit=879847**

- **中文名**：**内存命中**。
    
- **场景**：你要找的书，正好就在你的书桌（内存）上。
    
- **动作**：直接拿来看，速度极快（纳秒级）。
    
- **数据**：这次查询中，有 87 万个页面是从内存里直接拿的。
    

> **read=622250** （这里是问题的根源！）

- **中文名**：**磁盘读取**。
    
- **场景**：你要找的书，书桌上没有！你必须跑到地下仓库（硬盘）去搬上来。
    
- **动作**：这是最慢的操作。
    
- **算账**：
    
    - 读了 622,250 个页面。
        
    - 每个页面 8KB。
        
    - 总数据量 = 622,250 × 8KB ≈ **4.7 GB**。
        
- **结论**：为了数这 248 万个数，数据库从硬盘上硬生生读了 4.7 GB 的文件。**这就是为什么它跑了 73 秒！**
    

> **dirtied=114**

- **中文名**：**脏页**。
    
- **解释**：在查询过程中，有 114 个页面被“弄脏”了（修改了）。
    
- **为什么查数据会修改数据？**：通常是因为设置了“提示位”（Hint Bits），标记这行数据对谁可见。这属于数据库的自我维护，数量不多，可以忽略。
    

> **written=12390**

- **中文名**：**写入磁盘**。
    
- **解释**：因为你要读的数据太多（4.7GB），内存（书桌）放不下了，数据库被迫把书桌上一些旧的、脏的页面先写回仓库（硬盘），腾出空间给你用。这也消耗了时间。
    

---

### 第五部分：为什么会这样？（特殊指标篇）

> **Heap Fetches: 2485841**

这是本报告中最具诊断价值的一行。

- **字面意思**：**回表（Heap）抓取次数**。
    
- **背景**：还记得第一部分说它用的是 Index Only Scan（仅索引扫描）吗？它承诺“只查目录，不翻书”。
    
- **现实**：这个指标告诉你，它**撒谎了**。
    
    - 它在目录（索引）里看到了记录，但是它**不确定**这条记录是不是有效的（可能被删了，可能对当前事务不可见）。
        
    - 于是，它被迫拿着目录号，去书架上翻出了这本书（Heap），确认它真的存在且有效。
        
- **数据解读**：
    
    - 你一共查到了 rows=2480978（248万行）。
        
    - 回表次数 Heap Fetches: 2485841（248万次）。
        
    - **结论**：几乎每一行数据，它都跑去回表查了一次！
        
    - **后果**：这就导致了“宽表”问题——因为表很宽，书很厚，每次回表都要读很大的数据量，最终导致了那个恐怖的 read=622250（4.7GB I/O）。
        

---

### 总结：这段日志告诉了我们什么故事？

把所有解释串起来，这段日志讲了这样一个故事：

1. **计划**：数据库打算走捷径，用“仅索引扫描”来快速数数。
    
2. **现实**：执行时发现，索引里的信息不够新（Heap Fetches 极高），没法直接确认数据有效性。
    
3. **补救**：数据库被迫对这 248 万行数据，每一行都去原始表里核实一遍。
    
4. **代价**：因为表很宽（50个字段），回表核实导致了巨大的 I/O 读取（read 了 4.7GB 数据）。
    
5. **结果**：本来应该 1 秒做完的事，最后花了 73 秒。